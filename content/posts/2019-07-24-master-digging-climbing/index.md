---
title: "How to Become a Better Software Developer: Digging and Climbing"
description: "How to become a better software developer? Read about my journey of mastering digging and climbing."
published: "2019-07-24T11:00Z"
modified: "2019-07-24T11:11Z"
thumbnail: "./images/trying-to-fly.jpg"
slug: become-better-software-developer-digging-climbing
tags: ["craftsmanship", "clean code", "architecture"]
recommended: ["the-path-of-software-development-craftsmanship", "unlearn-javascript-bad-coding-habits"]
type: post
---

The journey of becoming a better software developer is tough. Mastering it requires time, dedication,  and choosing the right learning directions.  

In this post, I will describe one approach that I use in my journey to become a better software developer.  

I'll be honest. You won't ready about any shortcuts. What's more important, you will understand the importance of choosing the right learning directions.  

## 1. Shallow knowledge

Probably the most difficult stage of becoming a software developer is the beginning. If you've just graduated, you've got only about 5-10% of the knowledge required for writing real-world applications.  

While I had been lucky to get into software development right while having my studies at the university, I still had around a few years just shallow knowledge of web development. It allowed me to keep my job, have income. 

But something wasn't' right. I felt a lack of deep knowledge. But the idea that things work ok for me now just made me agree with the shallow knowledge I had.  

Somehow, everything went well enough until the team I was working with got a big web-based Java project, for a Romanian government agency. The application used Java on the server side, JavaScript libraries and HTML/CSS on the client side.  

![Mistakes in software development](./images/sinking-ship.jpg)

As usual, my team was productive at the beginning. But as time passed by, the functionality of the application grew, and the shallow knowledge of the whole team (including myself) I was working with started to manifest itself.  

After about 1 year in the project, it was increasingly hard to add new features. The bugs were manifesting themselves too often. Eventually, the project failed.  

Not that I didn't want the project to succeed, it was the opposite. But I concluded that the shallow knowledge, lack of deliberate learning towards the programming language and tech stack are the source of the problems.  

I decided to dig into Frontend.    

## 2. I started digging

The first thing is to advance into the programming language you're using every day. In my case, it was JavaScript.  

I didn't want to waste my time on superficial learning. I decided to dig as deep as I can.  

A good book I found on JavaScript was ["JavaScript: The Definitive Guide"](https://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527). It took me more than 6 months to dig into JavaScript specifics, try every code snippet, re-read multiple times the difficult parts.  

Then followed ["CSS: The Missing Manual"](https://www.amazon.com/CSS-Missing-David-Sawyer-McFarland/dp/1491918055). CSS is known for its property for being hard to master. That's true!

![Software development digging](./images/dig3.jpg)

While moving slowly in understanding JavaScript details, often I felt a huge relief. The concepts I've been struggling so many times in the past are now so easy to use.  

Overall, did I get the results I wanted? Partially.  

I knew how to use efficiently the programming language. I made lots of performance optimizations. I wrote better applications by applying my Frontend knowledge. But still... I was missing something important.  

The problem manifests itself by increasing difficulty when adding new components to the application. I felt like I was thrown back to the beginning. It was a bit disappointing.  

Turns out, if you dig too much into implementation details, you don't develop a vision of the whole picture. You cannot efficiently design functions, classes, and components that are well structured and loosely interact with each other.  

Ok, I have to climb through the abstract principles of a good system design.  

## 3. I started climbing

Again, I've decided to read a detailed book on how to organize efficiently the system components.  

The problem with abstract principles is that they are... too abstract. The brain cannot visualize them, cannot attach them to something material. You might read about a particular principle (e.g. [Open/Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)), but when exactly to use it within your application?  

I've started my journey of climbing by reading ["Clean Code"](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) page by page. It provides a good grasp over how to structure your functions and classes, how to make them focused on a single task.  

Then I've continued my journey by understanding coding recipes: the design patterns. I particularly enjoyed [Pro JavaScript Design Patterns](https://www.amazon.com/Pro-JavaScript-Design-Patterns-Object-Oriented/dp/159059908X).  

Again, it wasn't enough for me. The next book ["Clean Architecture"](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164) wasn't easy. I didn't want to miss any detail, so I read the book page by page for about 1 year. At least for me, understanding the principles of clean architecture is hard.  

I repeat the principles of good design ([SOLID](https://en.wikipedia.org/wiki/SOLID), [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), [SoC](https://en.wikipedia.org/wiki/Separation_of_concerns), etc) over and over again. Having them always circulating in my head helps me identify the places to use them.  

![Software development climbing](./images/climb.jpg)

Step by step I develop the ability to identify and fix structural problems before they get into the code. Step by step I become a better software developer. I like this feeling.  

What defines a good software? The software that is soft, i.e. easy to change and maintain. That's the main lesson I learn from climbing on abstract principles.  

## 4. Conclusion

The journey of becoming a good software developer is long and difficult. There are no shortcuts. Who said is going to be easy?  

Shallow knowledge is good for staying in your comfort zone. But the disappointment of writing crappy code is much bigger.  

To become a better software developer, dig into learning the details of your tech stack. At the same time climb over abstract principles of good system design.

The books I've chosen for my journey might not work for you. That's ok. Choose the ones that you like, and go for it. The sooner, the better! 

*What approach do you use to become a better software developer? Please write a comment below!*
